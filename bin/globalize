#!/usr/bin/env node
var fs, path, pkg, argv, glob, when, fn, nodefn,
	jsFilesRx, blacklistRx, dirs, name, main,
	readFile, writeFile, transform, header, footer, fakeRequire,
	defineShimPrefix, defineShimSuffix, extractModuleNameRx;

argv = require('optimist')
	.usage('Usage $0 -o output-file [input-files...]')
	.options('o', {
		alias: 'output',
		demand: 'true',
		describe: 'Output js file'
	})
	.argv;

dirs = argv._.length ? argv._ : ['unfold/*.js', 'node/*.js', './*.js'];
blacklistRx = /debug\.js|monitor\/|timed\.js|globalized/;
jsFilesRx = /\.js$/;
extractModuleNameRx = new RegExp(process.cwd().replace('/', '\\/') + '\\/(.+)\\.js$');

when = require('../when');
fn = require('../function');
nodefn = require('../node/function');

fs = require('fs');
path = require('path');
glob = nodefn.lift(require('glob'));
readFile = nodefn.lift(fs.readFile);
writeFile = nodefn.lift(fs.writeFile, argv.o);

pkg = JSON.parse(fs.readFileSync('./package.json'));
name = pkg.name;
main = pkg.main || name;

fakeRequire = 'function(id) {return id.split(\'./\')[1] == \'' + main + '\' ? window.' + main + ' : window[id.replace(\'../\', \'' + name + '.\')]; }';

header = ';(function(window,require){';
footer = 'try{delete window.define;}catch(e){window.define=void 0;}}(this,'
	+ fakeRequire.toString() + '));';
defineShimPrefix = 'window.define = function(factory) { window.';
defineShimSuffix = ' = factory(require); }; window.define.amd = {};\n';

// Construct a pipeline that will transform a single file in the
// way we need: get the full path, read its text content, remove the
// require function if present, generate a global var name for it,
// then add a define() shim
transform = fn.compose(
	path.resolve,
	getTextContent,
	apply(globalName),
	apply(prependNamespace(name, main)),
	apply(addDefineShim)
);

// Collect all the module files we want to include
when.map(dirs, glob)
	.then(function(fileSets) {
		// Filter and sort the files
		return fileSets.concat.apply([], fileSets).filter(shouldInclude).reverse();
	})
	.then(function(files) {
		// transform all of them
		return when.map(files, transform);
	})
	.then(function(processed) {
		// Form the final output blob
		return header + processed.join('') + footer;
	})
	.then(writeFile)
	.otherwise(console.error);

//---------------------------------------------------------
// Pipeline helpers

function shouldInclude(file) {
	return jsFilesRx.test(file) && !blacklistRx.test(file);
}

// Get the text content of a file
// Returns the pair [file, content]
function getTextContent(file) {
	return when.join(file, readFile(file).then(String));
}

// Generate a global var name for the module based on its
// file path.  content is left untouched, and simply threaded through
// Returns the pair [globalName, content]
function globalName(file, content) {

	var match, global;

	match = extractModuleNameRx.exec(file);
	global = match && match[1];

	if(!global) {
		throw new Error('Cannot generate global name: ' + file);
	}

	return [global, content];
}

function prependNamespace(ns, main) {
	return function(global, content) {
		return [global == main ? global : (ns+'.'+global.replace('/', '_')), content];
	}
}

// Adds a define shim for the supplied globalVarName at
// the beginning of the content.
// Returns the modified content
function addDefineShim(name, content) {
	return defineShimPrefix + name + defineShimSuffix + content;
}

//---------------------------------------------------------
// Other helpers

// Given a function, returns a new function that accepts an array
// and spreads it onto f's argument list.
function apply(f) {
	return function(args) {
		return f.apply(this, args);
	};
}
