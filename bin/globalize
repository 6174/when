#!/usr/bin/env node
var fs, path, pkg, argv, glob, minimatch, when, fn, nodefn,
	jsFilesRx, dirs, name, main, excludes,
	readFile, writeFile, transform, header, footer, fakeRequire,
	defineShimPrefix, defineShimSuffix, extractModuleNameRx;

argv = require('optimist')
	.usage('Usage $0 -o output-file [input-files...]')
	.options('o', {
		alias: 'output',
		demand: 'true',
		describe: 'Output js file'
	})
	.options('x', {
		alias: 'exclude',
		describe: 'Exclude a file or files'
	})
	.argv;

dirs = argv._.length ? argv._ : ['./*.js'];
jsFilesRx = /\.js$/;
extractModuleNameRx = new RegExp(process.cwd().replace('/', '\\/') + '\\/(.+)\\.js$');

when = require('../when');
fn = require('../function');
nodefn = require('../node/function');

fs = require('fs');
path = require('path');
glob = require('glob');
minimatch = require('minimatch');
readFile = nodefn.lift(fs.readFile);
writeFile = nodefn.lift(fs.writeFile, argv.o);

pkg = JSON.parse(fs.readFileSync('./package.json'));
name = pkg.name;
main = pkg.main || name;

fakeRequire = 'function(id) {return id.split(\'./\')[1] == \'' + main + '\' ? window.' + main + ' : window[id.replace(\'../\', \'' + name + '.\')]; }';

header = ';(function(window,require){';
footer = 'try{delete window.define;}catch(e){window.define=void 0;}}(this,'
	+ fakeRequire.toString() + '));';
defineShimPrefix = 'window.define = function(factory) { window.';
defineShimSuffix = ' = factory(require); }; window.define.amd = {};\n';

excludes = makeExcludes(argv.x, argv.o);

// Construct a pipeline that will transform a single file in the
// way we need: get the full path, read its text content, remove the
// require function if present, generate a global var name for it,
// then add a define() shim
transform = fn.compose(
	getTextContent,
	apply(globalName),
	apply(prependNamespace(name, main)),
	apply(addDefineShim)
);

// Collect all the module files we want to include
when.map(dirs, nodefn.lift(glob))
	.then(function(fileSets) {
		// Filter and sort the files
		return fileSets.concat.apply([], fileSets)
			.map(function(p) { return path.resolve(p); })
			.filter(excludes).sort(whenFirst);
	})
	.then(function(files) {
		console.log(files);
		// transform all of them
		return when.map(files, transform);
	})
	.then(function(processed) {
		// Form the final output blob
		return header + processed.join('') + footer;
	})
	.then(writeFile)
	.otherwise(console.error);

//---------------------------------------------------------
// Pipeline helpers

// Get the text content of a file
// Returns the pair [file, content]
function getTextContent(file) {
	return when.join(file, readFile(file).then(String));
}

// Generate a global var name for the module based on its
// file path.  content is left untouched, and simply threaded through
// Returns the pair [globalName, content]
function globalName(file, content) {

	var match, global;

	match = extractModuleNameRx.exec(file);
	global = match && match[1];

	if(!global) {
		throw new Error('Cannot generate global name: ' + file);
	}

	return [global, content];
}

// This *creates a function* that will add global namespace
// to global name if necessary
// The returned function returns the pair [namespacedGlobalName, content]
function prependNamespace(ns, main) {
	return function(global, content) {
		return [global == main ? global : (ns+'.'+global.replace('/', '_')), content];
	}
}

// Adds a define shim for the supplied globalVarName at
// the beginning of the content.
// Returns the modified content
function addDefineShim(name, content) {
	return defineShimPrefix + name + defineShimSuffix + content;
}

//---------------------------------------------------------
// Other helpers

function makeExcludes(excludes, outfile) {
	var ex;

	if(!excludes) {
		return function() { return true; }
	} else {
		ex = Array.isArray(excludes) ? excludes : [excludes];
	}

	// Ensure we never include the output file in the input!
	outfile = path.resolve(outfile);
	ex = ex.map(minimatch.filter).concat(function(p) {
		return p === outfile;
	});

	return function(p) {
		return !ex.some(function(mm) {
			return mm(p);
		});
	};
}

function whenFirst(a, b) {
	a = path.basename(a);
	b = path.basename(b);

	return a < b ? 1
		: a > b ? -1
			: 0;
}

// Given a function, returns a new function that accepts an array
// and spreads it onto f's argument list.
function apply(f) {
	return function(args) {
		return f.apply(this, args);
	};
}
